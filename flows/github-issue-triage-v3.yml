id: github-issue-triage
namespace: hackathon
description: |
  Automatically triages GitHub issues using AI.
  Reads open issues, categorizes them, applies labels, and posts triage comments.

inputs:
  - id: github_token
    type: STRING
    displayName: GitHub Token

  - id: openrouter_api_key
    type: STRING
    displayName: OpenRouter API Key

  - id: repo_owner
    type: STRING
    defaults: "drubo-nath"

  - id: repo_name
    type: STRING
    defaults: "issue-triage-demo"

  - id: dry_run
    type: STRING
    displayName: Dry Run Mode
    description: "Set to 'true' to preview actions without making changes, 'false' to apply labels and post comments"
    defaults: "true"

tasks:
  - id: fetch_issues
    type: io.kestra.plugin.core.http.Request
    uri: "https://api.github.com/repos/{{ inputs.repo_owner }}/{{ inputs.repo_name }}/issues?state=open&per_page=10"
    method: GET
    headers:
      Authorization: "Bearer {{ inputs.github_token }}"
      Accept: "application/vnd.github+json"
      X-GitHub-Api-Version: "2022-11-28"

  - id: triage_agent
    type: io.kestra.plugin.ai.agent.AIAgent
    provider:
      type: io.kestra.plugin.ai.provider.OpenAI
      modelName: amazon/nova-2-lite-v1:free
      apiKey: "{{ inputs.openrouter_api_key }}"
      baseUrl: "https://openrouter.ai/api/v1"
    systemMessage: |
      You are a GitHub Issue Triage Agent. Analyze issues and return ONLY a valid JSON object.
      
      Return this exact structure (no markdown, no explanation, just JSON):
      {
        "issues": [
          {
            "number": <issue_number>,
            "title": "<issue_title>",
            "category": "<bug|enhancement|question|documentation>",
            "priority": "<P1|P2|P3|P4>",
            "labels": ["<label1>", "<label2>"],
            "comment": "<helpful triage response>"
          }
        ],
        "summary": "<brief overall health summary>"
      }
      
      Label mapping:
      - bug -> ["bug", "P1"] or ["bug", "P2"] based on severity
      - enhancement -> ["enhancement", "P3"] or ["enhancement", "P4"]
      - question -> ["question", "P3"]
      - documentation -> ["documentation", "P2"]
      
      Keep comments concise (2-3 sentences). Be helpful and professional.
    prompt: |
      Analyze these GitHub issues and return structured JSON:
      
      {{ outputs.fetch_issues.body }}

  - id: log_ai_response
    type: io.kestra.plugin.core.log.Log
    message: "AI Response: {{ outputs.triage_agent.textOutput }}"

  - id: apply_actions
    type: io.kestra.plugin.scripts.python.Script
    warningOnStdErr: false
    docker:
      image: python:3.11-slim
    beforeCommands:
      - pip install kestra -q
    env:
      GITHUB_TOKEN: "{{ inputs.github_token }}"
      REPO_OWNER: "{{ inputs.repo_owner }}"
      REPO_NAME: "{{ inputs.repo_name }}"
      DRY_RUN: "{{ inputs.dry_run }}"
      AI_RESPONSE: "{{ outputs.triage_agent.textOutput }}"
    script: |
      import os
      import json
      import re
      import urllib.request
      import urllib.error

      github_token = os.environ['GITHUB_TOKEN']
      repo_owner = os.environ['REPO_OWNER']
      repo_name = os.environ['REPO_NAME']
      dry_run_raw = os.environ.get('DRY_RUN', 'true')
      ai_response = os.environ['AI_RESPONSE']

      dry_run = dry_run_raw.lower().strip() != 'false'
      
      print(f"Mode: {'DRY RUN' if dry_run else 'LIVE'}")
      print(f"Repository: {repo_owner}/{repo_name}")
      print("-" * 50)

      # Parse JSON from AI response (handle potential markdown wrapping)
      def extract_json(text):
          # Try to find JSON in markdown code blocks
          json_match = re.search(r'```(?:json)?\s*([\s\S]*?)\s*```', text)
          if json_match:
              return json_match.group(1)
          # Try to find raw JSON object
          json_match = re.search(r'\{[\s\S]*\}', text)
          if json_match:
              return json_match.group(0)
          return text

      def github_api(endpoint, method='GET', data=None):
          url = f"https://api.github.com/repos/{repo_owner}/{repo_name}/{endpoint}"
          headers = {
              'Authorization': f'Bearer {github_token}',
              'Accept': 'application/vnd.github+json',
              'X-GitHub-Api-Version': '2022-11-28',
              'Content-Type': 'application/json'
          }
          req = urllib.request.Request(url, method=method, headers=headers)
          if data:
              req.data = json.dumps(data).encode('utf-8')
          try:
              with urllib.request.urlopen(req) as response:
                  return json.loads(response.read().decode('utf-8'))
          except urllib.error.HTTPError as e:
              print(f"  ‚ùå API Error: {e.code} - {e.read().decode('utf-8')}")
              return None

      try:
          json_str = extract_json(ai_response)
          triage_data = json.loads(json_str)
      except json.JSONDecodeError as e:
          print(f"‚ùå Failed to parse AI response as JSON: {e}")
          print(f"Raw response: {ai_response[:500]}")
          exit(1)

      issues = triage_data.get('issues', [])
      summary = triage_data.get('summary', 'No summary provided')

      print(f"\nüìã Found {len(issues)} issues to process\n")

      actions_taken = []

      for issue in issues:
          issue_num = issue.get('number')
          title = issue.get('title', 'Unknown')
          labels = issue.get('labels', [])
          comment = issue.get('comment', '')
          category = issue.get('category', 'unknown')
          priority = issue.get('priority', 'P4')

          print(f"üìå Issue #{issue_num}: {title}")
          print(f"   Category: {category} | Priority: {priority}")
          print(f"   Labels: {labels}")

          if dry_run:
              print(f"   üî∏ [DRY RUN] Would apply labels: {labels}")
              print(f"   üî∏ [DRY RUN] Would post comment: {comment[:100]}...")
          else:
              # Apply labels
              if labels:
                  result = github_api(f"issues/{issue_num}/labels", method='POST', data={"labels": labels})
                  if result:
                      print(f"   ‚úÖ Labels applied: {labels}")
                  else:
                      print(f"   ‚ö†Ô∏è Failed to apply labels")

              # Post comment
              if comment:
                  comment_body = f"ü§ñ **AI Triage Bot**\n\n{comment}\n\n---\n*Category: {category} | Priority: {priority}*"
                  result = github_api(f"issues/{issue_num}/comments", method='POST', data={"body": comment_body})
                  if result:
                      print(f"   ‚úÖ Comment posted")
                  else:
                      print(f"   ‚ö†Ô∏è Failed to post comment")

          actions_taken.append({
              "issue": issue_num,
              "labels": labels,
              "commented": bool(comment),
              "dry_run": dry_run
          })
          print()

      print("-" * 50)
      print(f"\nüìä Summary: {summary}")
      print(f"\n‚úÖ Processed {len(issues)} issues ({'DRY RUN' if dry_run else 'LIVE'})")

      # Output results for Kestra
      from kestra import Kestra
      Kestra.outputs({
          "issues_processed": len(issues),
          "dry_run": dry_run,
          "actions": actions_taken,
          "summary": summary
      })

  - id: report
    type: io.kestra.plugin.core.debug.Return
    format: |
      ## üéØ GitHub Issue Triage Report
      
      **Repository:** {{ inputs.repo_owner }}/{{ inputs.repo_name }}
      **Mode:** {{ inputs.dry_run == 'true' and 'üî∏ DRY RUN (preview only)' or '‚úÖ LIVE (changes applied)' }}
      
      ### AI Analysis
      {{ outputs.triage_agent.textOutput }}
      
      ### Actions Summary
      - Issues processed: {{ outputs.apply_actions.vars.issues_processed }}
      - Dry run: {{ outputs.apply_actions.vars.dry_run }}
